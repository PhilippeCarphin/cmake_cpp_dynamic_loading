import time
print()
print("PYTHON   : Importing libpyspooki_interface")
import sys

def pyprint(message):
    print("PYTHON   : " + message)

if(sys.platform == "darwin"):
    sys.path.append("@CMAKE_CURRENT_BIN_DIR@")
import pyspooki_interface as interface

print()
print("PYTHON   : Creating an instance of a class")
my_class = interface.pyspooki_interface_class()

print()
print("PYTHON   : Calling a method of the class")
my_class.method()

print()
print("PYTHON   : Calling a regular exported function")
interface.pyspooki_interface_function()

print()
print("PYTHON   : Calling interface.tanh_impl(2.0)")
result = interface.tanh_impl(2.0)
print("PYTHON   : Result of tanh_impl: {}".format(result))


print()
print("PYTHON   : Calling interface.run_absolute_value_plugin")
interface.run_absolute_value_plugin()


print("==== create_a_shared_ptr =====")
def create_a_shared_ptr():
    print("PYTHON   : Calling returing_shared_ptr_test ...")
    a = interface.returning_shared_ptr_test("create_a_shared_ptr")
    print("PYTHON   : back from returning_shared_ptr_test")

pyprint("create_a_shared_ptr()")
create_a_shared_ptr()
pyprint("back from create_a_shared_ptr")

print("========= return_a_shared_ptr() =======")
def return_a_shared_ptr():
    return interface.returning_shared_ptr_test("return_a_shared_ptr")

def py_ref_count(x):
    return sys.getrefcount(x) - 3

pyprint("b = return_a_shared_ptr()")
b = return_a_shared_ptr()
pyprint("b.ref_count() : {}, py_ref_count(b) : {}".format(b.ref_count(), py_ref_count(b)))

print("========== REFERENCE COUNTING ===========")
pyprint("c = b")
c = b
pyprint("b.ref_count() : {}, py_ref_count(b) : {} (we have two python variables pointing to the same python object which has a std::shared_ptr)".format(b.ref_count(), py_ref_count(b)))

pyprint("d = interface.copy(b)")
d = interface.copy(b)
pyprint("b.ref_count() : {}, py_ref_count(b) : {}  (we now have two std::shared_ptr sharing the TestObject)".format(b.ref_count(), py_ref_count(b)))
pyprint("d.ref_count() : {}, py_ref_count(d) : {}  (and two different python objects and d's object is only referenced by d)".format(d.ref_count(), py_ref_count(d)))

pyprint("c = 4")
c = 4
pyprint("b.ref_count() : {}, py_ref_count(b) : {}".format(b.ref_count(), py_ref_count(b)))

pyprint("d = 4")
d = 4
pyprint("b.ref_count() : {}, py_ref_count(b) : {}".format(b.ref_count(), py_ref_count(b)))

pyprint("b = interface.copy(b)")
b = interface.copy(b)
pyprint("b.ref_count() : {}, py_ref_count(b) : {}".format(b.ref_count(), py_ref_count(b)))


pyprint("b = 4")
b = 4
pyprint("no more TestObject")

print("getting test object manual")
c = interface.TestObject("manual")











print("PYTHON   : SCRIPT END")